'''
Various tools for plotting
'''

from pylab import *
import tables


class AttributeToItem(object):

    '''
    Convenience class so you can write obj.name instead of obj['name'],
    useful for row objects returned from PyTables
    '''

    def __init__(self, obj):
        self.obj = obj

    def __getitem__(self, name):
        return self.obj[name]

    def __getattr__(self, name):
        return self.obj[name]


class SpikeTable(object):

    '''
    Class for loading data from a .h5 file generated by SpikeDetekt

    Usage::

        st = SpikeTable(filename)
        ...
        st.close()

    Some properties include::

        st.numspikes
        st.numchannels
        st.features_per_channel
        st.numfeatures
        st.samples_per_spike

    You can access an individual spike like this::

        spike = st[0]

    or::

        for spike in st:
            ...

    For a spike object, or for the entire spike table, you can access the
    stored attributes like this::

        spike.wave
        st.fet

    These return arrays, so if spike.wave has shape
    (samples_per_spike, numchannels) then st.wave would have shape
    (numspikes, samples_per_spike, numchannels) and so forth.

    Available attributes and their shapes for a spike include:

        time            (1)
        wave            (samples_per_spike, numchannels)
        fet             (numchannels, features_per_channel)
        channel_mask    (numchannels)
        fet_mask        (numfeatures)

    These are defined in spike_dtype() in files.py
    '''

    def __init__(self, filename):
        self.filename = filename
        self.hdf5file = tables.openFile(filename)
        self.spiketable = self.hdf5file.root.SpikeTable_temp
        self.numspikes = len(self.spiketable)
        self.numchannels = self.spiketable[0]['wave'].shape[1]
        self.features_per_channel = self.spiketable[0]['fet'].shape[1]
        self.numfeatures = self.spiketable[0]['fet_mask'].shape[0]
        self.samples_per_spike = self.spiketable[0]['wave'].shape[0]

    def __getitem__(self, i):
        return AttributeToItem(self.spiketable[i])

    def close(self):
        self.hdf5file.close()

    def __getattr__(self, name):
        return getattr(self.spiketable.cols, name)[:]

if __name__ == '__main__':
    from mpl_toolkits.mplot3d import Axes3D
    st = SpikeTable(
        '../testdata/originalmed_buzsaki32/originalmed_buzsaki32.h5')
    print 'Filename:', st.filename
    print 'Num spikes:', st.numspikes
    print 'Num channels:', st.numchannels
    print 'Features per channel:', st.features_per_channel
    print 'Num features:', st.numfeatures
    print 'Samples per spike:', st.samples_per_spike

    show_demo = False
    show_sample_spikes = True

    if show_demo:
        figure()

        # plot a wave for a spike with 5 unmasked channels
        subplot(221)
        for spike in st:
            if sum(spike.channel_mask) == 5:
                break
        plot(spike.wave, c=(0.8,) * 3)
        plot(spike.wave[:, spike.channel_mask.nonzero()[0]])
        title("Wave with unmasked channels")

        # plot channel
        gcf().add_subplot(222, projection='3d')
        fet = st.fet[:1000, :, :]
        for i, c in enumerate(['red', 'green', 'blue']):
            gca().scatter(fet[:, i, 0], fet[:, i, 1], fet[:, i, 2],
                          s=10, marker='.', facecolor=c, edgecolor='none')
        title("Features (XYZ) channels (RGB)")

        # unfiltered
        subplot(223)
        plot(spike.unfiltered_wave, c=(0.8,) * 3)
        plot(spike.unfiltered_wave[:, spike.channel_mask.nonzero()[0]])
        title("Unfiltered")

        # histogram of number of unmasked channels
        num_unmasked = [sum(spike.channel_mask) for spike in st]
        subplot(224)
        hist(num_unmasked, bins=arange(st.numchannels + 1))
        title('Number of unmasked channels')

    if show_sample_spikes:
        figure()
        i = 1
        for spike in st:
            # Finds positive threshold spikes only
#            if -amin(spike.wave)>amax(spike.wave):
#                continue
            # Finds only spikes with 3 or more channels
            if sum(spike.channel_mask) < 3:
                continue
            subplot(4, 4, i)
            plot(spike.wave, c=(0.8,) * 3)
            plot(spike.wave[:, spike.channel_mask.nonzero()[0]])
            axvline(spike.wave.shape[0] / 2, ls='--', c='k')
            axis('tight')
            xticks([])
            yticks([])
            i += 1
            if i > 16:
                break

    st.close()
    show()
